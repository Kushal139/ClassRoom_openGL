#version 330 core
layout(location = 0) in vec3 vertexPosition_modelspace;
layout(location = 1) in vec2 vertexUV;
layout(location = 2) in vec3 vertexNormal_modelspace;

const int NUM_LIGHTS = 9;

out vec2 UV;
out vec3 lightingColor;

uniform mat4 MVP;
uniform mat4 V;
uniform mat4 M;

uniform vec3 LightPosition_worldspace[NUM_LIGHTS];
uniform vec3 materialColor;
uniform bool useTexture;

void main() {
    gl_Position = MVP * vec4(vertexPosition_modelspace, 1.0);
    UV = vertexUV;

    vec3 pos_world  = (M * vec4(vertexPosition_modelspace,1)).xyz;
    vec3 pos_camera = (V * vec4(pos_world,1)).xyz;

    vec3 N = normalize((V * M * vec4(vertexNormal_modelspace,0)).xyz);
    vec3 E = normalize(-pos_camera);

    vec3 diffuseColor  = materialColor;
    vec3 specularColor = vec3(0.3);
    vec3 ambientColor  = 0.1 * diffuseColor;

    float LightPower = 2.0;
    vec3 LightColor = vec3(1.0);

    vec3 result = ambientColor;

    for (int i=0;i<NUM_LIGHTS;i++) {
        vec3 lightpos_camera = (V * vec4(LightPosition_worldspace[i],1)).xyz;
        vec3 L = normalize(lightpos_camera - pos_camera);

        float cosTheta = max(dot(N, L), 0.0);
        vec3 R = reflect(-L, N);
        float cosAlpha = max(dot(E, R), 0.0);

        float distance = length(LightPosition_worldspace[i] - pos_world);
        float attenuation = LightPower / (distance * distance);

        result += diffuseColor  * LightColor * attenuation * cosTheta +
                  specularColor * LightColor * attenuation * pow(cosAlpha, 5.0);
    }

    lightingColor = result;
}
